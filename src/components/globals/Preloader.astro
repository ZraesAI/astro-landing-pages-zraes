---
// Preloader component - Web3 Theme with Neural Network animation
---

<div id="preloader" class="fixed inset-0 z-[9999] bg-brand-background flex items-center justify-center transition-opacity duration-500">
  <!-- Background dengan pattern Web3 -->
  <div class="absolute inset-0 overflow-hidden">
    <div class="absolute inset-0 bg-gradient-to-br from-brand-background via-brand-surface to-brand-background"></div>
    <!-- Grid pattern -->
    <div class="absolute inset-0 opacity-[0.03]" style="background-image: linear-gradient(var(--color-primary) 1px, transparent 1px), linear-gradient(90deg, var(--color-primary) 1px, transparent 1px); background-size: 60px 60px;"></div>
    <!-- Glowing orbs -->
    <div class="absolute top-1/4 left-1/4 w-96 h-96 bg-brand-primary/10 rounded-full blur-[150px] animate-pulse"></div>
    <div class="absolute bottom-1/4 right-1/4 w-96 h-96 bg-brand-secondary/10 rounded-full blur-[150px] animate-pulse" style="animation-delay: 1s;"></div>
  </div>

  <!-- Neural Network Canvas -->
  <canvas id="preloader-neural" class="absolute inset-0 w-full h-full opacity-30"></canvas>

  <!-- Content Container -->
  <div id="preloader-content" class="relative z-10 flex flex-col items-center justify-center gap-8 text-center">
    <!-- Logo/Text ZRAES AI -->
    <div class="relative">
      <h1 class="text-4xl md:text-6xl font-bold tracking-wider relative z-10">
        <span class="bg-gradient-to-r from-brand-primary via-brand-secondary to-brand-primary bg-[length:200%_auto] bg-clip-text text-transparent animate-[gradient_3s_ease_infinite]"> ZRAES AI </span>
      </h1>
      <!-- Glow effect -->
      <div class="absolute inset-0 bg-gradient-to-r from-brand-primary/30 via-brand-secondary/30 to-brand-primary/30 blur-2xl opacity-50 animate-pulse"></div>
    </div>

    <!-- Tagline -->
    <p class="text-brand-text-secondary text-sm md:text-base tracking-widest uppercase">Decentralized Bot Intelligence</p>

    <!-- Progress Bar -->
    <div class="w-64 md:w-80 h-1 bg-brand-surface rounded-full overflow-hidden border border-brand-primary/20">
      <div id="progress-bar" class="h-full bg-gradient-to-r from-brand-primary via-brand-secondary to-brand-primary rounded-full transition-all duration-300" style="width: 0%"></div>
    </div>

    <!-- Loading Text -->
    <div class="flex items-center gap-2 text-brand-primary text-sm">
      <div class="w-2 h-2 rounded-full bg-brand-primary animate-pulse"></div>
      <span class="loading-text">Initializing Neural Network...</span>
    </div>
  </div>

  <!-- Final cursor dot that remains after closing -->
  <div id="final-cursor-dot" class="absolute w-[10px] h-[10px] rounded-full bg-[#66fcf1] opacity-0 pointer-events-none z-[10001]" style="box-shadow: 0 0 10px rgba(102, 252, 241, 0.5), 0 0 20px rgba(102, 252, 241, 0.3);"></div>
</div>

<style>
  @keyframes gradient {
    0%,
    100% {
      background-position: 0% 50%;
    }
    50% {
      background-position: 100% 50%;
    }
  }

  .loading-text {
    animation: textPulse 2s ease-in-out infinite;
  }

  @keyframes textPulse {
    0%,
    100% {
      opacity: 0.7;
    }
    50% {
      opacity: 1;
    }
  }
</style>

<script>
  // Neural Network for Preloader
  const initPreloaderNeural = () => {
    const canvas = document.getElementById("preloader-neural") as HTMLCanvasElement;
    if (!canvas) return;

    const ctx = canvas.getContext("2d");
    if (!ctx) return;

    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    const nodes: Array<{ x: number; y: number; vx: number; vy: number }> = [];
    const nodeCount = 30;

    for (let i = 0; i < nodeCount; i++) {
      nodes.push({
        x: Math.random() * canvas.width,
        y: Math.random() * canvas.height,
        vx: (Math.random() - 0.5) * 0.8,
        vy: (Math.random() - 0.5) * 0.8,
      });
    }

    const animate = () => {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      nodes.forEach((node, i) => {
        node.x += node.vx;
        node.y += node.vy;

        if (node.x < 0 || node.x > canvas.width) node.vx *= -1;
        if (node.y < 0 || node.y > canvas.height) node.vy *= -1;

        ctx.beginPath();
        ctx.arc(node.x, node.y, 3, 0, Math.PI * 2);
        ctx.fillStyle = "rgba(102, 252, 241, 0.6)";
        ctx.fill();

        nodes.forEach((other, j) => {
          if (i === j) return;
          const dx = node.x - other.x;
          const dy = node.y - other.y;
          const dist = Math.sqrt(dx * dx + dy * dy);

          if (dist < 150) {
            ctx.beginPath();
            ctx.moveTo(node.x, node.y);
            ctx.lineTo(other.x, other.y);
            ctx.strokeStyle = `rgba(102, 252, 241, ${0.2 * (1 - dist / 150)})`;
            ctx.lineWidth = 1;
            ctx.stroke();
          }
        });
      });

      requestAnimationFrame(animate);
    };

    animate();
  };

  initPreloaderNeural();

  // Track cursor position
  let cursorX = window.innerWidth / 2;
  let cursorY = window.innerHeight / 2;
  let hasCursorPosition = false;

  // Track mouse movement - update immediately on any mouse activity
  const trackMouse = (e: MouseEvent) => {
    cursorX = e.clientX;
    cursorY = e.clientY;
    hasCursorPosition = true;
  };

  // Track mouse position on any mouse event (move, enter, over)
  const trackMouseEnter = (e: MouseEvent) => {
    cursorX = e.clientX;
    cursorY = e.clientY;
    hasCursorPosition = true;
  };

  const trackMouseOver = (e: MouseEvent) => {
    cursorX = e.clientX;
    cursorY = e.clientY;
    hasCursorPosition = true;
  };

  // Add multiple event listeners to catch cursor position
  document.addEventListener("mousemove", trackMouse, { passive: true });
  document.addEventListener("mouseenter", trackMouseEnter, { passive: true });
  document.addEventListener("mouseover", trackMouseOver, { passive: true });

  // Initialize with center position
  cursorX = window.innerWidth / 2;
  cursorY = window.innerHeight / 2;

  // Also track touch for mobile
  const updateTouchPosition = (e: TouchEvent) => {
    if (e.touches.length > 0) {
      cursorX = e.touches[0].clientX;
      cursorY = e.touches[0].clientY;
      hasCursorPosition = true;
    }
  };
  document.addEventListener("touchstart", updateTouchPosition);
  document.addEventListener("touchmove", updateTouchPosition);

  // Wait for critical resources to load (optimized for faster loading)
  const waitForImages = (): Promise<void> => {
    return new Promise((resolve) => {
      // Only wait for images that are above the fold or critical
      const images = Array.from(document.querySelectorAll("img"));
      const criticalImages = images.filter((img) => {
        // Check if image is in viewport or has loading="eager"
        const rect = img.getBoundingClientRect();
        const isAboveFold = rect.top < window.innerHeight * 2;
        const isEager = img.getAttribute("loading") === "eager" || !img.hasAttribute("loading");
        return isAboveFold || isEager;
      });

      const imagePromises = criticalImages.map((img) => {
        if (img.complete) return Promise.resolve();
        return new Promise<void>((imgResolve) => {
          // Timeout after 1 second to prevent waiting too long
          const timeout = setTimeout(() => imgResolve(), 1000);
          img.onload = () => {
            clearTimeout(timeout);
            imgResolve();
          };
          img.onerror = () => {
            clearTimeout(timeout);
            imgResolve(); // Resolve even on error
          };
        });
      });

      // Set minimum display time for smooth UX (reduced from 300ms to 100ms)
      const minDisplayTime = 100;

      if (document.readyState === "complete") {
        Promise.all(imagePromises).then(() => {
          setTimeout(() => resolve(), minDisplayTime);
        });
      } else {
        // Wait for DOMContentLoaded instead of full load for faster response
        if (document.readyState === "loading") {
          document.addEventListener("DOMContentLoaded", () => {
            Promise.all(imagePromises).then(() => {
              setTimeout(() => resolve(), minDisplayTime);
            });
          });
        } else {
          Promise.all(imagePromises).then(() => {
            setTimeout(() => resolve(), minDisplayTime);
          });
        }
      }
    });
  };

  // Simulate progress bar (faster progression)
  const simulateProgress = () => {
    const progressBar = document.getElementById("progress-bar");
    if (!progressBar) return;

    let progress = 0;
    const interval = setInterval(() => {
      progress += Math.random() * 20 + 10; // Faster progression (10-30 per interval)
      if (progress > 95) progress = 95; // Don't complete until everything is loaded
      progressBar.style.width = `${progress}%`;
    }, 80); // Faster interval (80ms instead of 100ms)

    return interval;
  };

  // Animate closing with cursor position - shrink into cursor like the custom cursor
  const animateClosing = () => {
    const preloader = document.getElementById("preloader");
    const preloaderContent = document.getElementById("preloader-content");
    const finalCursorDot = document.getElementById("final-cursor-dot");

    if (!preloader) return;

    // Get the latest cursor position at the moment of closing
    let targetX = cursorX;
    let targetY = cursorY;

    const isInitialCenter = targetX === window.innerWidth / 2 && targetY === window.innerHeight / 2;

    // If we have a valid cursor position that's not the initial center, use it
    if (hasCursorPosition && !isNaN(targetX) && !isNaN(targetY) && !isInitialCenter) {
      targetX = cursorX;
      targetY = cursorY;
    } else {
      // Fallback to center if no valid cursor position
      targetX = window.innerWidth / 2;
      targetY = window.innerHeight / 2;
    }

    // Ensure coordinates are within viewport bounds
    targetX = Math.max(0, Math.min(targetX, window.innerWidth));
    targetY = Math.max(0, Math.min(targetY, window.innerHeight));

    // Calculate the maximum radius needed to cover the entire screen from cursor position
    const distances = [
      Math.sqrt(Math.pow(targetX, 2) + Math.pow(targetY, 2)),
      Math.sqrt(Math.pow(window.innerWidth - targetX, 2) + Math.pow(targetY, 2)),
      Math.sqrt(Math.pow(targetX, 2) + Math.pow(window.innerHeight - targetY, 2)),
      Math.sqrt(Math.pow(window.innerWidth - targetX, 2) + Math.pow(window.innerHeight - targetY, 2)),
    ];
    const maxRadius = Math.max(...distances) * 1.2;

    // Position the final cursor dot
    if (finalCursorDot) {
      finalCursorDot.style.left = `${targetX}px`;
      finalCursorDot.style.top = `${targetY}px`;
      finalCursorDot.style.transform = "translate(-50%, -50%)";
    }

    // Fade out content first
    if (preloaderContent) {
      preloaderContent.style.transition = "opacity 0.3s ease-out, transform 0.5s ease-in";
      preloaderContent.style.opacity = "0";
      preloaderContent.style.transform = `translate(${(targetX - window.innerWidth / 2) * 0.1}px, ${(targetY - window.innerHeight / 2) * 0.1}px) scale(0.9)`;
    }

    // Use clip-path to create the shrinking circle effect
    // Start with full coverage, end with tiny circle at cursor
    setTimeout(() => {
      preloader.style.transition = "clip-path 0.8s cubic-bezier(0.77, 0, 0.175, 1)";
      preloader.style.clipPath = `circle(${maxRadius}px at ${targetX}px ${targetY}px)`;

      // Force reflow
      preloader.offsetHeight;

      // Animate to small circle (cursor size)
      requestAnimationFrame(() => {
        preloader.style.clipPath = `circle(5px at ${targetX}px ${targetY}px)`;
      });
    }, 100);

    // Show the final cursor dot just before the preloader fully closes
    setTimeout(() => {
      if (finalCursorDot) {
        finalCursorDot.style.transition = "opacity 0.2s ease-out";
        finalCursorDot.style.opacity = "1";
      }
    }, 700);

    // Fade out the final dot and remove preloader
    setTimeout(() => {
      if (finalCursorDot) {
        finalCursorDot.style.transition = "opacity 0.3s ease-out, transform 0.3s ease-out";
        finalCursorDot.style.opacity = "0";
        finalCursorDot.style.transform = "translate(-50%, -50%) scale(0.5)";
      }
    }, 900);

    // Remove preloader after animation
    setTimeout(() => {
      preloader.style.display = "none";
      document.body.style.overflow = "";
      // Clean up event listeners
      document.removeEventListener("mousemove", trackMouse);
      document.removeEventListener("mouseenter", trackMouseEnter);
      document.removeEventListener("mouseover", trackMouseOver);
      document.removeEventListener("touchstart", updateTouchPosition);
      document.removeEventListener("touchmove", updateTouchPosition);
    }, 1000);
  };

  // Initialize preloader
  const initPreloader = async () => {
    const preloader = document.getElementById("preloader");
    if (!preloader) return;

    // Prevent body scroll
    document.body.style.overflow = "hidden";

    // Start progress bar simulation
    const progressInterval = simulateProgress();

    // Set maximum wait time (2 seconds) to prevent preloader from showing too long
    const maxWaitTime = setTimeout(() => {
      // Force close if taking too long
      const progressBar = document.getElementById("progress-bar");
      if (progressBar) {
        progressBar.style.width = "100%";
      }
      if (progressInterval) {
        clearInterval(progressInterval);
      }
      setTimeout(() => {
        animateClosing();
      }, 100);
    }, 2000);

    // Wait for critical resources to load
    await waitForImages();

    // Clear max wait timeout since we loaded successfully
    clearTimeout(maxWaitTime);

    // Complete progress bar
    const progressBar = document.getElementById("progress-bar");
    if (progressBar) {
      progressBar.style.width = "100%";
    }

    // Clear progress interval
    if (progressInterval) {
      clearInterval(progressInterval);
    }

    // Wait a bit more for smooth transition (reduced from 200ms to 100ms)
    setTimeout(() => {
      animateClosing();
    }, 100);
  };

  // Start preloader when DOM is ready
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initPreloader);
  } else {
    initPreloader();
  }
</script>
